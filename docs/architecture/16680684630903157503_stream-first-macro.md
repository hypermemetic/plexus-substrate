# Stream-First Hub Macro System

## Overview

The hub macro system generates all boilerplate for registering activations with the Plexus. Users write only:
- Event types (with `#[derive(StreamEvent)]`)
- Plugin struct
- Method implementations (with `#[hub_methods]` / `#[hub_method]`)

The macro generates:
- Method enum for schema extraction
- `Activation` trait implementation
- Stream event `ActivationStreamItem` implementation

## User-Facing API

### 1. Define Event Types

```rust
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, StreamEvent)]
#[stream_event(content_type = "bash.event")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum BashEvent {
    Stdout { line: String },
    Stderr { line: String },
    #[terminal]  // Marks stream completion
    Exit { code: i32 },
}
```

The `#[terminal]` attribute marks variants that signal stream end. The macro generates:
```rust
impl ActivationStreamItem for BashEvent {
    fn is_terminal(&self) -> bool {
        matches!(self, Self::Exit { .. })
    }
}
```

### 2. Define Plugin and Methods

```rust
#[derive(Clone)]
pub struct BashActivation { /* ... */ }

#[hub_methods(namespace = "bash", version = "1.0.0")]  // crate_path defaults to "crate"
impl BashActivation {
    /// Execute a command and stream output
    #[hub_macro::hub_method]
    async fn execute(&self, command: String) -> impl Stream<Item = BashEvent> + Send + 'static {
        self.executor.run(&command)
    }

    /// Kill a running process
    #[hub_macro::hub_method]
    async fn kill(&self, pid: u32) -> impl Stream<Item = KillEvent> + Send + 'static {
        // ...
    }
}
```

### 3. Register with Plexus

```rust
let plexus = Plexus::new()
    .register(BashActivation::new())
    .register(HealthActivation::new());

// Schema is automatically available
let schema = plexus.get_activation_schema("bash");
```

## Generated Code

For `BashActivation`, the macro generates:

### Method Enum
```rust
#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(tag = "method", content = "params")]
pub enum BashActivationMethod {
    Execute(String),
    Kill(u32),
}
```

### Activation Implementation
```rust
impl Activation for BashActivation {
    type Methods = BashActivationMethod;  // For schema generation

    fn namespace(&self) -> &str { "bash" }
    fn version(&self) -> &str { "1.0.0" }
    fn methods(&self) -> Vec<&str> { vec!["execute", "kill"] }

    async fn call(&self, method: &str, params: Value) -> Result<PlexusStream, PlexusError> {
        match method {
            "execute" => { /* deserialize, call, wrap stream */ }
            "kill" => { /* ... */ }
            _ => Err(PlexusError::MethodNotFound { .. })
        }
    }
}
```

## Macro Module Structure

```
hub-macro/src/
├── lib.rs            - Proc macro entry points
├── parse.rs          - Attribute and method parsing
├── stream_event.rs   - #[derive(StreamEvent)] implementation
└── codegen/
    ├── mod.rs        - Orchestrates code generation
    ├── method_enum.rs - Generates {Struct}Method enum
    └── activation.rs  - Generates Activation trait impl
```

## Key Design Decisions

### 1. Stream-First, No Session Types
Session types (dialectic) were removed. The stream item enum IS the protocol:
- Variants = possible events
- `#[terminal]` = stream end marker
- JsonSchema = wire format documentation

### 2. Macro Generates, User Writes Logic
The macro handles all registration plumbing. Users focus on:
- What events can be emitted
- How to produce those events

### 3. Schema from Types
`type Methods = BashActivationMethod` enables automatic schema extraction via schemars. The Plexus can expose full API documentation at runtime.

## Terminal Detection

The `#[terminal]` attribute solves: "How does the client know the stream is done?"

```rust
enum BashEvent {
    Stdout { line: String },     // Not terminal - more may come
    #[terminal]
    Exit { code: i32 },          // Terminal - stream ends here
}
```

Generated `is_terminal()`:
```rust
fn is_terminal(&self) -> bool {
    match self {
        Self::Exit { .. } => true,
        _ => false,
    }
}
```

For struct types (single response), `is_terminal()` always returns `true`.

## Migration Path

Existing activations can be migrated incrementally:
1. Add `#[derive(StreamEvent)]` to event types with `#[terminal]` markers
2. Add `#[hub_methods]` to impl block
3. Add `#[hub_macro::hub_method]` to each method
4. Remove manual `Activation` impl

The generated code is compatible with the existing Plexus API.
