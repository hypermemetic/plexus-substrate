# Help System Architecture

## Overview

The substrate implements a **self-documenting help system** that provides contextual guidance at every level of interaction. The design principle: **errors should point, not dump**—every error directs the user toward discovery without overwhelming them with the full schema.

## Progressive Disclosure

The help system uses **progressive disclosure**—the closer you get to a valid request, the more specific the guidance becomes:

| Error Level | What's Wrong | Help Shows |
|-------------|--------------|------------|
| Parse error | Can't understand request | Protocol format + `plexus_schema` example |
| Activation not found | `foo_*` - no such activation | List of available activations |
| Method not found | `bash_foo` - no such method | Methods available in `bash` |
| Invalid params | `bash_execute` - wrong args | Method signature + example |

This mirrors CLI behavior:
```
$ git foo           → "git: 'foo' is not a git command. See 'git --help'"
$ git commit --foo  → Shows commit usage with valid options
```

## The `try` Pattern

Every guided error includes a `data.try` field containing an exact JSON-RPC request to make next:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Activation 'foo' not found",
    "data": {
      "available_activations": ["arbor", "bash", "cone", "health"],
      "try": {"jsonrpc": "2.0", "id": 1, "method": "plexus_schema", "params": []}
    }
  }
}
```

The `try` field is:
- **Copy-pasteable**: Users can immediately try the suggested request
- **Machine-readable**: Clients can auto-retry with the suggested request
- **Minimal**: Just one request, not the whole schema

## Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│  Substrate (Protocol Guidance)                              │
│  "I speak JSON-RPC 2.0 over WebSocket"                      │
│  Handles: Parse errors, protocol format                     │
├─────────────────────────────────────────────────────────────┤
│  Plexus (Method Discovery)                                  │
│  "Here's what you can call"                                 │
│  Handles: Activation/method not found, invalid params       │
├─────────────────────────────────────────────────────────────┤
│  Activations (Domain Help)                                  │
│  "Here's how to use this method"                            │
│  Provides: method_help(), enrich_schema()                   │
└─────────────────────────────────────────────────────────────┘
```

## Components

### PlexusError

**File**: `src/plexus/plexus.rs`

Semantic errors without RPC knowledge:

```rust
pub enum PlexusError {
    ActivationNotFound(String),
    MethodNotFound { activation: String, method: String },
    InvalidParams(String),
    ExecutionError(String),
}
```

### PlexusSchema (Discovery Endpoint)

**File**: `src/plexus/plexus.rs`

The `plexus_schema` subscription returns all available activations and methods:

```rust
pub struct PlexusSchema {
    pub activations: Vec<ActivationInfo>,
    pub total_methods: usize,
}

pub struct ActivationInfo {
    pub namespace: String,
    pub version: String,
    pub description: String,
    pub methods: Vec<String>,
}
```

This is the entry point for programmatic discovery—errors guide users here.

### Activation Trait (Help Methods)

**File**: `src/plexus/plexus.rs`

Every activation provides help through the trait:

```rust
pub trait Activation: Send + Sync + 'static {
    fn namespace(&self) -> &str;
    fn version(&self) -> &str;
    fn description(&self) -> &str { "No description available" }
    fn methods(&self) -> Vec<&str>;
    fn method_help(&self, method: &str) -> Option<String>;
    fn enrich_schema(&self) -> Schema;
    // ...
}
```

### method_help() Implementation

Each activation implements `method_help()` to provide contextual documentation:

**Health** (`src/activations/health/activation.rs`):
```rust
fn method_help(&self, method: &str) -> Option<String> {
    match method {
        "check" => Some(
            "Check the health status of the hub.\n\
            \n\
            Parameters: none\n\
            \n\
            Returns:\n\
              { type: \"status\", data: { status: string, uptime_seconds: number, timestamp: number } }\n\
            \n\
            Example:\n\
              hub-cli health.check".to_string()
        ),
        _ => None,
    }
}
```

**Bash** (`src/activations/bash/activation.rs`):
```rust
fn method_help(&self, method: &str) -> Option<String> {
    match method {
        "execute" => Some(
            "Execute a bash command and stream stdout, stderr, and exit code.\n\
            \n\
            Parameters:\n\
              command (string): The bash command to execute\n\
            \n\
            Returns stream of events:\n\
              - stdout: { type: \"stdout\", data: { line: string } }\n\
              - stderr: { type: \"stderr\", data: { line: string } }\n\
              - exit:   { type: \"exit\", data: { code: number } }\n\
            \n\
            Example:\n\
              hub-cli bash.execute 'echo hello world'".to_string()
        ),
        _ => None,
    }
}
```

### Plexus Discovery Methods

**File**: `src/plexus/plexus.rs`

The plexus provides methods to query the help system:

```rust
impl Plexus {
    /// List all methods in "namespace.method" format
    pub fn list_methods(&self) -> Vec<String>;

    /// List all activations with metadata
    pub fn list_activations(&self) -> Vec<ActivationInfo>;

    /// Get help text for a specific method
    pub fn get_method_help(&self, namespace: &str, method: &str) -> Option<String>;

    /// Get enriched schema for an activation
    pub fn get_activation_schema(&self, namespace: &str) -> Option<Schema>;
}
```

## Schema Enrichment

**File**: `src/plexus/schema.rs`

The schema system provides rich JSON Schema with type enrichment for fields that can't be auto-derived (like UUIDs).

### Enrichment Process

1. **Auto-generate** base JSON schema from method enum using `schemars`
2. **Parse** schema into strongly-typed `Schema` representation
3. **Call `.describe()`** on each method variant to get enrichment data
4. **Apply enrichments** (UUID formats, descriptions, required flags)

### Key Types

```rust
pub struct Schema {
    pub schema_version: Option<String>,
    pub title: Option<String>,
    pub description: Option<String>,
    pub schema_type: Option<Value>,
    pub properties: Option<HashMap<String, SchemaProperty>>,
    pub required: Option<Vec<String>>,
    pub one_of: Option<Vec<Schema>>,
    pub defs: Option<HashMap<String, Value>>,
}

pub struct SchemaProperty {
    pub property_type: Option<Value>,
    pub description: Option<String>,
    pub format: Option<String>,        // "uuid", "date-time", etc.
    pub items: Option<Box<SchemaProperty>>,
    pub default: Option<Value>,
    pub enum_values: Option<Vec<Value>>,
}
```

### Describe Trait

```rust
pub trait Describe {
    fn describe(&self) -> Option<MethodEnrichment> { None }
}

pub struct MethodEnrichment {
    pub method_name: String,
    pub fields: Vec<FieldEnrichment>,
}

pub struct FieldEnrichment {
    pub name: String,
    pub format: Option<String>,
    pub description: Option<String>,
    pub required: bool,
}

impl FieldEnrichment {
    pub fn uuid(name: &str, description: &str, required: bool) -> Self;
}
```

### Arbor Enrichment Example

**File**: `src/activations/arbor/methods.rs`

```rust
pub fn describe_by_name(method_name: &str) -> Option<MethodEnrichment> {
    let fields = match method_name {
        "tree_get" | "tree_get_skeleton" | "tree_render" => {
            vec![FieldEnrichment::uuid("tree_id", "UUID of the tree", true)]
        }
        "node_get" | "node_get_children" | "node_get_parent" => {
            vec![
                FieldEnrichment::uuid("tree_id", "UUID of the tree", true),
                FieldEnrichment::uuid("node_id", "UUID of the node", true),
            ]
        }
        // ... more patterns
    };
    Some(MethodEnrichment { method_name, fields })
}
```

## Error Response Examples

### Parse Error (Non-JSON-RPC)

```json
{
  "jsonrpc": "2.0",
  "id": null,
  "error": {
    "code": -32700,
    "message": "Parse error: This server speaks JSON-RPC 2.0 over WebSocket",
    "data": {
      "try": {"jsonrpc": "2.0", "id": 1, "method": "plexus_schema", "params": []}
    }
  }
}
```

### Activation Not Found

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Activation 'foo' not found",
    "data": {
      "available_activations": ["arbor", "bash", "cone", "health"],
      "try": {"jsonrpc": "2.0", "id": 1, "method": "plexus_schema", "params": []}
    }
  }
}
```

### Method Not Found

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method 'foo' not found in activation 'bash'",
    "data": {
      "activation": "bash",
      "available_methods": ["execute"],
      "try": {"jsonrpc": "2.0", "id": 1, "method": "bash_execute", "params": ["echo hello"]}
    }
  }
}
```

### Invalid Params

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Invalid params for bash_execute: missing 'command'",
    "data": {
      "method": "bash_execute",
      "usage": "bash_execute [command: string]",
      "description": "Execute shell command, stream output",
      "example": {"jsonrpc": "2.0", "id": 1, "method": "bash_execute", "params": ["echo hello"]}
    }
  }
}
```

## Configuration

```rust
struct SubstrateConfig {
    /// Include help hints in error responses (default: true)
    error_guidance: bool,
}
```

When `error_guidance: false`, errors are minimal:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Method not found: foo_bar"
  }
}
```

## Discovery Flow

```
Client sends garbage
       │
       ▼
┌──────────────────────────────────────────────┐
│ Substrate: "I speak JSON-RPC 2.0. Try this:" │
│ {"jsonrpc":"2.0","id":1,"method":            │
│  "plexus_schema","params":[]}                │
└──────────────────────────────────────────────┘
       │
       ▼
Client sends plexus_schema request
       │
       ▼
┌──────────────────────────────────────────────┐
│ Plexus: Returns all activations and methods  │
│ {activations: [...], total_methods: N}       │
└──────────────────────────────────────────────┘
       │
       ▼
Client now knows what to call
```

## Implementation Status

### Implemented

- `PlexusError` enum with all variants
- `method_help()` on all activations (health, bash, arbor, cone)
- `plexus_schema` subscription for discovery
- Schema enrichment infrastructure
- `Describe` trait and `FieldEnrichment` types
- Plexus discovery methods (`list_methods`, `list_activations`, etc.)

### Pending

- RPC error handler middleware to convert `PlexusError` → guided JSON-RPC
- `error_guidance` configuration flag integration
- Full `try` field generation in error responses

## Key Files

| File | Purpose |
|------|---------|
| `src/plexus/plexus.rs` | PlexusError, PlexusSchema, Activation trait |
| `src/plexus/schema.rs` | Schema types, Describe trait, enrichment |
| `src/activations/*/activation.rs` | method_help() implementations |
| `src/activations/arbor/methods.rs` | Arbor schema enrichment |

## Related

- [Self-Documenting RPC](./16680998353176467711_self-documenting-rpc.md) - Original design document
- [Substrate Architecture](./16680975879064433663_substrate-architecture.md) - Overall system architecture
